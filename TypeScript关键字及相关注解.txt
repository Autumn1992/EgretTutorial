

########变量声明定义
#let        在一个作用域下只能定义一次(for多层循环可多次定义且后定义会覆盖前者) 可传入函数形成闭包 即生成单独的执行环境
            let使用的是词法作用域或块作用域 超出作用域之外是无法再访问的
#var        在一个作用域下可重复多次定义 不可形成闭包 var作用域或函数作用域 
            var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问 代码块定义不影响访问
#const      作用域规则同let 赋值后值不可再改变


########基础数据类型
#boolean    false | true 布尔值
#number     数字(浮点数) 十进制 八进制 十六进制 二进制均可定义 由赋值前缀决定
#string     字符串 可以使用双引号"及单引号‘表示 字符串内嵌表达式 ${变量名或表达式} (像jsp之类的网页脚本)
#[] Array   数组 支持固定数组和泛型数组 let list: number[] = [1, 2, 3] or Array<number> 数组下标从0开始？

#元组Tuple  类似hashtable let x: [string, number] x[0] = key x[1] = value
            当访问越界元素时 会使用联合类似(联合定义的限制类型 string | number) 
            x[3] = 'word' //ok 字符串可以赋值给(string | number)类型

#enum       枚举
#Any        用于定义编译阶段还不确定的类型 类似Object差异于Any可以直接调用任意该类型上存在的方法 而不用转类型
            也可用于定义Any[]数组

#Void       和Any相反 表示没有任何类型 void类型变量只能赋值null或者undefined   
#Null和Undefined 默认情况下 该两者是所有类型的子类型 可以把 null和undefined赋值给所有类型
#--strictNullChecks 严格空检查 null和undefined只能赋值给void和它们各自 此时基础数据类型不可再赋值null和undefined
#Never      永不存在的值的类型 一般用于函数返回值：抛出异常 返回异常 死循环永不返回

####类型断言
            <数据类型>变量名 or 变量名 as 数据类型 
            类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。
            TypeScript会假设你，程序员，已经进行了必须的检查

####解构
##数组及变量解构 用[ ]
#变量赋值   let input = [1, 2]; let [a, b] = input; //a b相当于定义的两个新变量
#函数参数   function f([first, second] : [number, number]) { }  f(input);  
#赋值变体   let[first, ...rest] = [1,2,3,4] //...语法创建剩余变量 rest = [2,3,4]
           let [first] = [1,2,3,4]; //first = 1 
           let [, second, , fourth] = [1, 2, 3, 4];
           //很像Lua的一些赋值规则
##对象解构 用{ } 
#对象解构   let o = { a: "foo",  b: 12, c: "bar" }; let { a, b } = o;

           //注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。
           解构匿名对象 ({ a, b } = { a: "baz", b: 101 }); 

           //你可以在对象里使用...语法创建剩余变量
           let { a, ...passthrough } = o;
           let total = passthrough.b + passthrough.c.length; 

           //属性重命名 
           let { a: newName1, b: newName2 } = o; 

           //默认值 默认值可以让你在属性为 undefined 时使用缺省值  ?:可选参数
           function keepWholeObject(wholeObject: { a: string, b?: number }) {
                let { a, b = 1001 } = wholeObject;
           }

#解构用于函数声明
            //:用于标记类似规范性约束或继承关系
            type C = { a: string, b?: number }
            function f({ a, b }: C): void { }
            //指定函数默认参数值
            function f({ a, b } = { a: "", b: 0 }): void { }

            function f({ a, b = 0 } = { a: "" }): void { }
            // ok, default b = 0
            f({ a: "yes" }); 
            // ok, default to {a: ""}, which then defaults b = 0
            f(); 
            // error, 'a' is required if you supply an argument
            f({}); 


####展开 与解构相反
            展开成对象 可用...连接 后续的同属性会覆盖前面已有的属性
            TypeScript编译器不允许展开泛型函数上的类型参数
            对象展开只能展开对象的自身的可枚举属性。 不可展开接口


#默认接口及class的作用域是public
############接口
            #TypeScript的核心原则之一是对值所具有的结构进行类型检查
            #TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约
            interface 接口名{ 变量名: 变量类型 } 一般用于函数参数做类型及结构检查
            可选属性 用变量名?: 变量类型 定义
            readonly修饰属性 只能在创建时赋值 

            ReadonlyArray<T> 只读不可修改和C#的readonly还不太一样 是真的只读不可赋值 只能get
            但可以通过as转换后赋值给其它变量   
            const和readonly 是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly

            #接口的额外属性检查 传入不存在的属性 error: '属性名' not expected in type '接口名'
            ##绕开额外属性检查  传入参数时先进行类型断言将参数转换成相应接口
                               //字符串索引签名
                               或是在接口中额外定义[propName: string]: any;表明接口会带有其它任意数量的其它属性
                               #不建议的一种绕开检查方式
                               let squareOptions = { colour: "red", width: 100 };
                               let mySquare = createSquare(squareOptions);
                               将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错
                               很low的方式 而且容易出bug 在写出可读性代码的前提下 写出这种代码可能同时
                               违背了你想要进行额外属性检查的初衷


####函数类型 接口也可以描述函数类型
#接口表示函数类型,给接口定义一个调用签名。是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。
            参数名字不需要匹配 但参数类型会依次检查是否兼容
            参数名可以不指定类型 但是TypeScript会根据定义的接口类型自动做推断出参数类型并编译

####可索引的类型 可索引类型具有一个索引签名 它用于描述对象索引的类型 还有相应的索引返回值类型
            interface StringArray { [index: number]: string; }
            let myArray: StringArray;
            myArray = ["Bob", "Fred"]; //索引从0开始
            #是否可以同时定义Add Remove之类的接口吗 类似做List接口？

            ##共有支持两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是
            字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string
            然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用"100"（一个string）去索引，
            因此两者需要保持一致
            class Animal {
                name: string;
            }
            class Dog extends Animal {
                breed: string;
            }
            // 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
            interface NotOkay {
                [x: number]: Animal;
                [x: string]: Dog;
            }

            #字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。
            #字符串索引声明了 obj.property和obj["property"]两种形式都可以
            #即name属性的访问和index的访问是一样的 最终index会先转换成string作为index去索引
            interface NumberDictionary {
                [index: string]: number;
                length: number;    // 可以，length是number类型
                name: string;      // 错误，`name`的类型与索引类型返回值的类型不匹配
            }
            #索引签名可以设置为只读 那么赋值后就不可再对索引赋值


#########面向对象相关关键字
#extends        继承class
#implements     实现接口 
#constructor    类构造器


####接口表示类类型
            #类实现一个接口时，只会对实例部分进行类型检查 静态部分不会检查(构造方法属于静态部分)
            #当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误
            interface ClockConstructor {
                new (hour: number, minute: number);
            }

            class Clock implements ClockConstructor {
                currentTime: Date;
                constructor(h: number, m: number) { }
            }
            #此处是实现了new接口的 但是constructor属于静态部分 不会做检查 编译器会报错说提供new签名接口
            #因此，我们应该直接操作类的静态部分 下面的例子，我们定义了两个接口， 
            ClockConstructor为构造函数所用和ClockInterface为实例方法所用
            #下面的示例ClockConstructor接口的工作原理类似于C#的where T : Object做类型约束
            #此处的new ctor(hour, minute)的运作及执行流程原理有点迷糊
            interface ClockConstructor {
                //单纯约束有个(hour: number, minute: number)的构造器且实现了ClockInterface
                new (hour: number, minute: number): ClockInterface;
            }
            interface ClockInterface {
                tick();
            }
            function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
                return new ctor(hour, minute);
            }
            class DigitalClock implements ClockInterface {
                constructor(h: number, m: number) { }
                tick() {
                    console.log("beep beep");
                }
            }
            class AnalogClock implements ClockInterface {
                constructor(h: number, m: number) { }
                tick() {
                    console.log("tick tock");
                }
            }
            let digital = createClock(DigitalClock, 12, 17);
            let analog = createClock(AnalogClock, 7, 32);


####继承接口
        #接口之间可以继承 且可以多继承
        interface Shape { color: string; }
        interface Square extends Shape { sideLength: number; } 
        #类型转换 类型断言
        let square = <Square>{ };  square.color = "blue"; square.sideLength = 10;

####混合类型
        #一个对象可以同时做为函数和对象使用，并带有额外的属性。
        interface Counter {
            #函数签名 返回值string
            (start: number): string; 
            interval: number;
            reset(): void;
        } 
        function getCounter(): Counter {
            let counter = <Counter>function (start: number) { };
            counter.interval = 123;
            counter.reset = function () { };
            return counter;
        }
        let c = getCounter();
        c(10);
        c.reset();
        c.interval = 5.0;

####接口继承类 很神的逻辑 弱类型约束的TypeScript有些语法和规则好奇特 感觉容易把人搞迷糊
        当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，
        但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一
        个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。
        当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了
        继承至基类外与基类没有任何关系。 例：
        class Control {
            private state: any;
        }
        interface SelectableControl extends Control {
            select(): void;
        }
        class Button extends Control implements SelectableControl {
            select() { }
        }
        class TextBox extends Control {
            select() { }
        }
        // 错误：“Image”类型缺少“state”属性。
        class Image implements SelectableControl {
            select() { }
        }
        class Location {

        }
        在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，
        所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明
        于Control的私有成员state，###！！！这对私有成员的兼容性是必需的。
