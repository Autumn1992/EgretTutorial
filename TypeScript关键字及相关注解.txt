

####变量声明定义
#let        在一个作用域下只能定义一次(for多层循环可多次定义且后定义会覆盖前者) 可传入函数形成闭包 即生成单独的执行环境
            let使用的是词法作用域或块作用域 超出作用域之外是无法再访问的
#var        在一个作用域下可重复多次定义 不可形成闭包 var作用域或函数作用域 
            var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问 代码块定义不影响访问
#const      作用域规则同let 赋值后值不可再改变

####基础数据类型
#boolean    false | true 布尔值
#number     数字(浮点数) 十进制 八进制 十六进制 二进制均可定义 由赋值前缀决定
#string     字符串 可以使用双引号"及单引号‘表示 字符串内嵌表达式 ${变量名或表达式} (像jsp之类的网页脚本)
#[] Array   数组 支持固定数组和泛型数组 let list: number[] = [1, 2, 3] or Array<number> 数组下标从0开始？

#元组Tuple  类似hashtable let x: [string, number] x[0] = key x[1] = value
            当访问越界元素时 会使用联合类似(联合定义的限制类型 string | number) 
            x[3] = 'word' //ok 字符串可以赋值给(string | number)类型

#enum       枚举
#Any        用于定义编译阶段还不确定的类型 类似Object差异于Any可以直接调用任意该类型上存在的方法 而不用转类型
            也可用于定义Any[]数组

#Void       和Any相反 表示没有任何类型 void类型变量只能赋值null或者undefined   
#Null和Undefined 默认情况下 该两者是所有类型的子类型 可以把 null和undefined赋值给所有类型
#--strictNullChecks 严格空检查 null和undefined只能赋值给void和它们各自
#Never      永不存在的值的类型 一般用于函数返回值：抛出异常 返回异常 死循环永不返回

####类型断言
            <数据类型>变量名 or 变量名 as 数据类型 
            类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。
            TypeScript会假设你，程序员，已经进行了必须的检查
